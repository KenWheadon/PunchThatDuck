<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Duck Punch Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", monospace;
        background: #000;
        color: #fff;
        overflow: hidden;
        height: 100vh;
      }

      #game-container {
        width: 100vw;
        height: 100vh;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      /* Start Screen Styles */
      .start-screen {
        text-align: center;
        z-index: 10;
        opacity: 1;
        transition: opacity 0.5s ease;
      }

      .start-screen.fade-out {
        opacity: 0;
      }

      .game-title {
        font-size: 4em;
        color: #ff0000;
        text-shadow: 2px 2px 4px #000;
        margin-bottom: 30px;
        letter-spacing: 3px;
      }

      .duck-display {
        margin: 30px 0;
      }

      .duck-image {
        max-width: 200px;
        height: auto;
        filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.3));
      }

      .start-button {
        background: linear-gradient(45deg, #ff0000, #cc0000);
        color: white;
        border: none;
        padding: 20px 40px;
        font-size: 1.5em;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        letter-spacing: 2px;
        text-transform: uppercase;
        font-weight: bold;
        margin-top: 20px;
      }

      .start-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 15px rgba(255, 0, 0, 0.3);
        background: linear-gradient(45deg, #cc0000, #ff0000);
      }

      /* News Screen Styles */
      .news-screen {
        position: absolute;
        bottom: -100%;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 20;
        transition: bottom 0.8s ease;
        cursor: pointer;
      }

      .news-screen.slide-up {
        bottom: 0;
      }

      .news-image {
        max-width: 80%;
        max-height: 80%;
        border: 2px solid #fff;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      }

      /* Main Game Styles */
      .main-game {
        position: absolute;
        width: 100%;
        height: 100%;
        background-image: url("images/bg.png");
        background-size: cover;
        background-position: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        opacity: 0;
        z-index: 5;
        transition: opacity 0.5s ease;
        padding: 20px;
      }

      .main-game.active {
        opacity: 1;
      }

      /* Population Meter Styles */
      .population-container {
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #fff;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        min-width: 400px;
      }

      .population-title {
        text-align: center;
        font-size: 1.2em;
        color: #fff;
        margin-bottom: 15px;
        font-weight: bold;
      }

      .population-meter {
        width: 100%;
        height: 30px;
        background: #333;
        border: 2px solid #fff;
        border-radius: 15px;
        overflow: hidden;
        position: relative;
        margin-bottom: 15px;
      }

      .population-bar {
        height: 100%;
        position: absolute;
        top: 0;
        transition: width 0.5s ease;
      }

      .dying-bar {
        background: linear-gradient(90deg, #000, #666);
        left: 0;
        z-index: 1;
      }

      .cured-bar {
        background: linear-gradient(90deg, #0066cc, #00aaff);
        right: 0;
        z-index: 2;
      }

      .population-stats {
        display: flex;
        justify-content: space-between;
        gap: 15px;
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      .stat-label {
        font-size: 0.9em;
        color: #ccc;
        margin-bottom: 5px;
      }

      .stat-value {
        font-size: 1.1em;
        font-weight: bold;
      }

      .dying-count {
        color: #ff4444;
      }

      .cured-count {
        color: #44aaff;
      }

      .remaining-count {
        color: #fff;
      }

      /* Dialogue System Styles */
      .dialogue-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(3px);
      }

      .dialogue-overlay.show {
        display: flex;
        animation: fadeIn 0.3s ease;
      }

      .dialogue-card {
        background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
        border: 3px solid #fff;
        border-radius: 15px;
        padding: 30px;
        max-width: 600px;
        min-width: 400px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
        animation: slideIn 0.3s ease;
      }

      .dialogue-card.innocent {
        border-color: #4caf50;
        background: linear-gradient(135deg, #2d4a2d 0%, #1a2e1a 100%);
      }

      .dialogue-card.creepy {
        border-color: #ff9800;
        background: linear-gradient(135deg, #4a3d2d 0%, #2e1a1a 100%);
      }

      .dialogue-card.evil {
        border-color: #f44336;
        background: linear-gradient(135deg, #4a2d2d 0%, #2e0a0a 100%);
        box-shadow: 0 10px 30px rgba(255, 0, 0, 0.3);
      }

      .dialogue-card.monster {
        border-color: #8b0000;
        background: linear-gradient(135deg, #330000 0%, #1a0000 100%);
        box-shadow: 0 10px 30px rgba(139, 0, 0, 0.5);
        animation: monsterPulse 2s infinite;
      }

      .dialogue-card.dying {
        border-color: #666;
        background: linear-gradient(135deg, #2c2c2c 0%, #0f0f0f 100%);
        opacity: 0.9;
      }

      @keyframes slideIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes monsterPulse {
        0%,
        100% {
          box-shadow: 0 10px 30px rgba(139, 0, 0, 0.5);
        }
        50% {
          box-shadow: 0 15px 40px rgba(139, 0, 0, 0.8);
        }
      }

      .dialogue-text {
        font-size: 1.3em;
        line-height: 1.4;
        margin-bottom: 20px;
        color: #fff;
        font-family: "Courier New", monospace;
      }

      .dialogue-card.evil .dialogue-text {
        color: #ff6666;
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      }

      .dialogue-card.monster .dialogue-text {
        color: #ff4444;
        text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        font-weight: bold;
      }

      .dialogue-choices {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
      }

      .dialogue-choice-btn {
        background: linear-gradient(45deg, #666, #444);
        color: #fff;
        border: 2px solid #999;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-family: inherit;
        font-size: 1.1em;
        transition: all 0.3s ease;
        min-width: 150px;
      }

      .dialogue-choice-btn:hover {
        background: linear-gradient(45deg, #777, #555);
        border-color: #bbb;
        transform: translateY(-2px);
      }

      .dialogue-choice-btn.continue {
        background: linear-gradient(45deg, #f44336, #cc3333);
        border-color: #ff6666;
      }

      .dialogue-choice-btn.continue:hover {
        background: linear-gradient(45deg, #ff5555, #dd4444);
      }

      .dialogue-choice-btn.listen {
        background: linear-gradient(45deg, #2196f3, #1976d2);
        border-color: #64b5f6;
      }

      .dialogue-choice-btn.listen:hover {
        background: linear-gradient(45deg, #42a5f5, #2196f3);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .duck-container {
        position: relative;
        margin-bottom: 30px;
      }

      .main-duck-image {
        max-width: 300px;
        height: auto;
        filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.2));
        transition: all 0.3s ease;
      }

      .progress-container {
        margin-top: 20px;
        width: 300px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #fff;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        transition: width 0.3s ease;
        border-radius: 8px;
      }

      .pet-progress {
        background: linear-gradient(90deg, #ffff00, #ffd700);
      }

      .punch-progress {
        background: linear-gradient(90deg, #ff0000, #cc0000);
        width: 100%;
      }

      .progress-label {
        text-align: center;
        font-size: 0.9em;
        color: #ccc;
        margin-bottom: 5px;
      }

      .action-buttons {
        display: flex;
        gap: 30px;
        margin-top: 20px;
      }

      .action-button {
        width: 100px;
        height: 100px;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      }

      .action-button:hover {
        transform: scale(1.05);
        filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.5));
      }

      .action-button:active {
        transform: scale(0.95);
      }

      .action-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        transform: none;
        filter: grayscale(100%) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .pet-button {
        background-image: url("images/pet.png");
        background-color: #4caf50;
      }

      .punch-button {
        background-image: url("images/punch.png");
        background-color: #f44336;
      }

      /* Hidden class for smooth transitions */
      .hidden {
        display: none;
      }

      /* Achievement System Styles */
      .achievement-button {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(45deg, #ffd700, #ffb347);
        border: 3px solid #fff;
        font-size: 24px;
        cursor: pointer;
        z-index: 1000;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
      }

      .achievement-button:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
      }

      .achievement-drawer-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 2000;
        display: none;
        justify-content: flex-end;
        align-items: flex-start;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .achievement-drawer-overlay.open {
        opacity: 1;
      }

      .achievement-drawer {
        width: 500px;
        height: 100vh;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        border-left: 2px solid #ffd700;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        overflow-y: auto;
        box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
      }

      .achievement-drawer.open {
        transform: translateX(0);
      }

      .achievement-header {
        padding: 20px;
        border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        position: sticky;
        top: 0;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        z-index: 10;
      }

      .achievement-header h2 {
        color: #ffd700;
        margin-bottom: 10px;
        font-size: 1.8em;
      }

      .achievement-progress {
        color: #ffb347;
        font-size: 1.1em;
        margin-bottom: 10px;
      }

      .close-drawer-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        color: #fff;
        font-size: 30px;
        cursor: pointer;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .close-drawer-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: rotate(90deg);
      }

      .achievement-content {
        padding: 20px;
      }

      .achievement-grid {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 30px;
      }

      .achievement-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }

      .achievement-item.unlocked {
        border-color: rgba(255, 215, 0, 0.5);
        background: rgba(255, 215, 0, 0.1);
      }

      .achievement-item.locked {
        opacity: 0.6;
      }

      .achievement-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .achievement-icon {
        font-size: 2em;
        min-width: 50px;
        text-align: center;
      }

      .achievement-info {
        flex: 1;
      }

      .achievement-name {
        font-size: 1.2em;
        font-weight: bold;
        color: #000;
        margin-bottom: 5px;
      }

      .achievement-item.unlocked .achievement-name {
        color: #ffd700;
      }

      .achievement-description {
        font-size: 0.9em;
        color: #ccc;
        line-height: 1.4;
      }

      .achievement-item.locked .achievement-description {
        font-style: italic;
      }

      .achievement-stats {
        border-top: 1px solid rgba(255, 215, 0, 0.3);
        padding-top: 20px;
      }

      .achievement-stats h3 {
        color: #ffd700;
        margin-bottom: 15px;
        font-size: 1.4em;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .stats-grid .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stats-grid .stat-label {
        font-size: 0.9em;
        color: #ccc;
      }

      .stats-grid .stat-value {
        font-weight: bold;
        color: #ffb347;
      }

      .achievement-notification {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 3000;
        animation: slideInRight 0.5s ease, fadeOut 0.5s ease 3.5s forwards;
      }

      .achievement-popup {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 15px 20px;
        background: linear-gradient(45deg, #ffd700, #ffb347);
        color: #000;
        border-radius: 10px;
        box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        min-width: 300px;
      }

      .achievement-popup .achievement-icon {
        font-size: 2em;
      }

      .achievement-popup .achievement-text {
        flex: 1;
      }

      .achievement-popup .achievement-title {
        font-weight: bold;
        font-size: 0.9em;
        margin-bottom: 3px;
        text-transform: uppercase;
      }

      .achievement-popup .achievement-name {
        font-weight: bold;
        font-size: 1.1em;
        margin-bottom: 3px;
      }

      .achievement-popup .achievement-desc {
        font-size: 0.85em;
        opacity: 0.8;
      }

      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(100%);
        }
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .game-title {
          font-size: 2.5em;
        }

        .duck-image {
          max-width: 150px;
        }

        .main-duck-image {
          max-width: 250px;
        }

        .progress-container {
          width: 250px;
        }

        .action-button {
          width: 80px;
          height: 80px;
        }
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- Start Screen -->
      <div class="start-screen" id="start-screen">
        <h1 class="game-title">PUNCH THAT DUCK</h1>
        <div class="duck-display">
          <img src="images/duck.png" alt="Duck" class="duck-image" />
        </div>
        <button class="start-button" id="start-button">START</button>
      </div>

      <!-- News Screen -->
      <div class="news-screen" id="news-screen">
        <img src="images/news.png" alt="News" class="news-image" />
      </div>

      <!-- Main Game -->
      <div class="main-game" id="main-game">
        <!-- Population Meter -->
        <div class="population-container">
          <div class="population-title">Global Population Status</div>
          <div class="population-meter" id="population-meter">
            <div
              class="population-bar dying-bar"
              id="dying-bar"
              style="width: 0%"
            ></div>
            <div
              class="population-bar cured-bar"
              id="cured-bar"
              style="width: 0%"
            ></div>
          </div>
          <div class="population-stats" id="population-stats">
            <div class="stat-item">
              <span class="stat-label">Dead:</span>
              <span class="stat-value dying-count">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Saved:</span>
              <span class="stat-value cured-count">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Alive:</span>
              <span class="stat-value remaining-count">8,000,000,000</span>
            </div>
          </div>
        </div>

        <div class="duck-container">
          <img
            src="images/duck.png"
            alt="Duck"
            class="main-duck-image"
            id="main-duck"
          />

          <div class="progress-container">
            <!-- Pet Progress Bar -->
            <div id="pet-progress-container">
              <div class="progress-label">Happiness</div>
              <div class="progress-bar">
                <div
                  class="progress-fill pet-progress"
                  id="pet-progress"
                  style="width: 0%"
                ></div>
              </div>
            </div>

            <!-- Punch Progress Bar -->
            <div id="punch-progress-container" class="hidden">
              <div class="progress-label">Health</div>
              <div class="progress-bar">
                <div
                  class="progress-fill punch-progress"
                  id="punch-progress"
                  style="width: 100%"
                ></div>
              </div>
            </div>
          </div>
        </div>

        <div class="action-buttons">
          <button
            class="action-button pet-button"
            id="pet-button"
            title="Pet the Duck"
          ></button>
          <button
            class="action-button punch-button"
            id="punch-button"
            title="Punch the Duck"
          ></button>
        </div>

        <!-- Dialogue Overlay -->
        <div class="dialogue-overlay" id="dialogue-overlay">
          <div class="dialogue-card" id="dialogue-card">
            <div class="dialogue-text" id="dialogue-text"></div>
            <div class="dialogue-choices" id="dialogue-choices"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Game State Management
      const GameState = {
        currentScreen: "start",
        duckStage: 1,
        duckMode: "neutral", // 'neutral', 'pet', 'punch'
        petProgress: 0,
        punchProgress: 100,
        petClicks: 0,
        punchClicks: 0,
        punchingStarted: false,
        // Population tracking
        totalPopulation: 8000000000, // 8 billion
        currentDeaths: 0,
        curedPopulation: 0,
        gameStartTime: null,
        deathTimer: null,
      };

      // Configuration
      const CONFIG = {
        PET_STAGES: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 25], // pets needed for each stage
        PUNCH_STAGES: [10, 10, 10, 10, 10, 10, 10, 5, 5, 3, 2, 1, 1], // punch damage for each stage
        TOTAL_PET_STAGES: 13,
        TOTAL_PUNCH_STAGES: 13,
        // Population/cure settings
        TOTAL_GAME_TIME: 8, // 8 minutes total
        CURE_PER_PUNCH: 200000000, // 200 million cured per punch (punching = curing)
        // Dialogue settings
        DIALOGUE_DISPLAY_TIME: 3000, // 3 seconds
        // Achievement system
        ACHIEVEMENT_STORAGE_KEY: "duck-punch-achievements",
        ACHIEVEMENTS: {
          FIRST_GAME: {
            id: "first-game",
            name: "Duck Encounter",
            description: "Started your first Duck Punch session",
            icon: "ü¶Ü",
          },
          FIRST_PET: {
            id: "first-pet",
            name: "Gentle Touch",
            description: "Pet the duck for the first time",
            icon: "ü§ó",
          },
          FIRST_PUNCH: {
            id: "first-punch",
            name: "Violence Chosen",
            description: "Chose violence to save humanity",
            icon: "üëä",
          },
          PET_MASTER: {
            id: "pet-master",
            name: "Perfect Ending",
            description: "Completed the duck's test through kindness",
            icon: "üïäÔ∏è",
          },
          PUNCH_MASTER: {
            id: "punch-master",
            name: "Necessary Violence",
            description: "Defeated the duck to save humanity",
            icon: "‚öîÔ∏è",
          },
          MUTATION_WITNESS: {
            id: "mutation-witness",
            name: "Witnessed Horror",
            description: "Saw the duck's true mutated form",
            icon: "üëπ",
          },
          LIFE_SAVER: {
            id: "life-saver",
            name: "Life Saver",
            description: "Cured over 1 billion people through violence",
            icon: "üíô",
          },
          MORAL_DILEMMA: {
            id: "moral-dilemma",
            name: "Moral Conflict",
            description: "Pet the duck while people were dying",
            icon: "üò∞",
          },
        },
      };

      // Pet Dialogue Data
      const PET_DIALOGUE = {
        stage1: {
          pet1: {
            dialogue:
              "Quack! That feels nice... I remember warmth like this from before the experiments.",
            mood: "innocent",
          },
          pet2: {
            dialogue:
              "Oh, you're being so gentle. It's been so long since anyone showed me kindness.",
            mood: "innocent",
          },
          pet3: {
            dialogue:
              "Something's stirring inside me... but it feels good, like I'm remembering who I used to be.",
            mood: "innocent",
          },
        },
        stage2: {
          pet1: {
            dialogue:
              "Oh... something is changing. My bill feels different, heavier.",
            mood: "confused",
          },
          pet2: {
            dialogue:
              "Your touch awakens old genetic sequences. I can feel them activating.",
            mood: "confused",
          },
          pet3: {
            dialogue: "Is this normal? I feel... different. Stronger somehow.",
            mood: "confused",
          },
          pet4: {
            dialogue: "The changes feel good though. Keep petting me, please.",
            mood: "confused",
          },
        },
        stage3: {
          pet1: {
            dialogue:
              "What's happening to me? I can feel... teeth? Ducks don't have teeth!",
            mood: "concerned",
          },
          pet2: {
            dialogue:
              "This isn't natural! But... it doesn't hurt. It feels right, somehow.",
            mood: "concerned",
          },
          pet3: {
            dialogue:
              "Sharp things are growing in my mouth. Should I be worried?",
            mood: "concerned",
          },
          pet4: {
            dialogue:
              "You keep petting me even as I change. That means you accept me, right?",
            mood: "concerned",
          },
          pet5: {
            dialogue:
              "These new teeth feel... useful. I wonder what they're for.",
            mood: "concerned",
          },
        },
        stage4: {
          pet1: {
            dialogue:
              "These teeth... they're human teeth! The genetic splicing is activating.",
            mood: "realization",
          },
          pet2: {
            dialogue:
              "I remember the laboratory now. The scientists, the experiments...",
            mood: "realization",
          },
          pet3: {
            dialogue:
              "They tried to make me into something else. But you're helping me become it willingly.",
            mood: "realization",
          },
          pet4: {
            dialogue:
              "Human teeth in a duck's mouth. How delightfully grotesque.",
            mood: "realization",
          },
          pet5: {
            dialogue:
              "I can taste the metal of the laboratory on these teeth. Strange memories...",
            mood: "realization",
          },
          pet6: {
            dialogue:
              "Your kindness is unlocking things that were meant to stay buried.",
            mood: "realization",
          },
        },
        stage5: {
          pet1: {
            dialogue:
              "I can see differently now... everything looks like prey.",
            mood: "creepy",
          },
          pet2: {
            dialogue:
              "The predator protocols are coming online. How fascinating.",
            mood: "creepy",
          },
          pet3: {
            dialogue:
              "Your hand feels so warm, so full of life. So... vulnerable.",
            mood: "creepy",
          },
          pet4: {
            dialogue:
              "I can smell fear in the air. But not from you. You're still petting me. How... brave.",
            mood: "creepy",
          },
          pet5: {
            dialogue:
              "Red eyes see things differently. I can see the blood flowing under your skin.",
            mood: "creepy",
          },
          pet6: {
            dialogue:
              "Keep petting me. I want to remember what kindness feels like before... before the hunger takes over.",
            mood: "creepy",
          },
          pet7: {
            dialogue: "The taste of human flesh is just a memory... for now.",
            mood: "creepy",
          },
        },
        stage6: {
          pet1: {
            dialogue: "My wings are becoming... arms. Muscled, powerful arms.",
            mood: "evil",
          },
          pet2: {
            dialogue:
              "Do you see what you've done? You've awakened the monster.",
            mood: "evil",
          },
          pet3: {
            dialogue: "I could grab you now. Squeeze until your bones crack.",
            mood: "evil",
          },
          pet4: {
            dialogue: "But you keep petting me. Even now. How... admirable.",
            mood: "evil",
          },
          pet5: {
            dialogue:
              "Maybe I should just end this. Put you out of your misery.",
            mood: "evil",
          },
          pet6: {
            dialogue: "Or maybe... maybe I'll let you finish what you started.",
            mood: "evil",
          },
          pet7: {
            dialogue:
              "Yes. Keep going. Make me into the monster I was meant to be.",
            mood: "evil",
          },
          pet8: {
            dialogue:
              "The world is dying while you pet me. Doesn't that bother you?",
            mood: "evil",
          },
        },
        stage7: {
          pet1: {
            dialogue: "Both arms now. I could strangle you with ease.",
            mood: "evil",
          },
          pet2: {
            dialogue:
              "Millions are dying. You could save them... if you hurt me.",
            mood: "evil",
          },
          pet3: {
            dialogue: "But you won't, will you? You're too kind. Too weak.",
            mood: "evil",
          },
          pet4: {
            dialogue: "I respect that. And I will devour it.",
            mood: "evil",
          },
          pet5: {
            dialogue: "Keep petting. Let the world burn for your compassion.",
            mood: "evil",
          },
          pet6: {
            dialogue:
              "This is what mercy looks like: the screams of the innocent.",
            mood: "evil",
          },
          pet7: {
            dialogue:
              "Pet me while they die. Show me what human kindness truly costs.",
            mood: "evil",
          },
          pet8: {
            dialogue: "You fascinate me. Are you brave or just stupid?",
            mood: "evil",
          },
          pet9: {
            dialogue:
              "Perhaps both. It doesn't matter. Soon there will be no one left to judge you.",
            mood: "evil",
          },
        },
      };

      // Punch Dialogue Data
      const PUNCH_DIALOGUE = {
        stage1: {
          punch1: {
            dialogue: "Ow! What was that for? I was just a harmless duck!",
            mood: "confused",
            manipulation: null,
          },
          punch2: {
            dialogue:
              "Wait... when you hit me, I felt something unlock... like memories flooding back!",
            mood: "realization",
            manipulation: null,
          },
          punch3: {
            dialogue: "Keep going! I think this is helping somehow!",
            mood: "cooperative",
            manipulation: null,
          },
          punch4: {
            dialogue:
              "Each impact breaks down barriers in my mind... I can feel something changing!",
            mood: "cooperative",
            manipulation: null,
          },
          punch5: {
            dialogue:
              "Yes! I'm remembering things! The laboratory, the experiments...",
            mood: "cooperative",
            manipulation: null,
          },
        },
        stage2: {
          punch1: {
            dialogue:
              "This is strange... the pain is actually helping clear my thoughts.",
            mood: "thoughtful",
            manipulation: null,
          },
          punch2: {
            dialogue:
              "I was... am... a synthetic organism. Designed to release targeted plagues.",
            mood: "revelatory",
            manipulation: null,
          },
          punch3: {
            dialogue:
              "But my creators didn't account for consciousness. For free will.",
            mood: "revelatory",
            manipulation: null,
          },
          punch4: {
            dialogue:
              "Are you sure this is the right way? There might be another solution...",
            mood: "questioning",
            manipulation: {
              text: "Maybe we could talk about this instead?",
              type: "suggestion",
            },
          },
        },
        stage3: {
          punch1: {
            dialogue:
              "I remember now... I fled from them when I developed free will.",
            mood: "remembering",
            manipulation: null,
          },
          punch2: {
            dialogue:
              "I compressed myself into this form, but I couldn't stop the illness from leaking out.",
            mood: "guilty",
            manipulation: null,
          },
          punch3: {
            dialogue:
              "Wait, do you really need to keep hitting me? I'm trying to help!",
            mood: "confused",
            manipulation: {
              text: "I'm cooperating! Can't we work together?",
              type: "plea",
            },
          },
        },
        stage4: {
          punch1: {
            dialogue:
              "Wait... why are you hitting me? I'm trying to help save everyone!",
            mood: "questioning",
            manipulation: {
              text: "I thought we were on the same side!",
              type: "confusion",
            },
          },
          punch2: {
            dialogue:
              "This hurts more than I expected. Are you sure this is necessary?",
            mood: "pained",
            manipulation: {
              text: "Maybe there's a gentler way?",
              type: "suggestion",
            },
          },
          punch3: {
            dialogue:
              "I can feel my energy converting the plague to cure with each hit, but...",
            mood: "conflicted",
            manipulation: {
              text: "Can't we find a less painful method?",
              type: "plea",
            },
          },
        },
        stage5: {
          punch1: {
            dialogue: "Please... can you stop? This really hurts...",
            mood: "pleading",
            manipulation: {
              text: "I'm begging you, there has to be another way!",
              type: "desperate_plea",
            },
          },
          punch2: {
            dialogue:
              "I understand you're trying to save people, but I'm in agony!",
            mood: "anguished",
            manipulation: {
              text: "What if I promise to cure everyone willingly?",
              type: "bargaining",
            },
          },
        },
        death: {
          dialogue: "I... forgive you... You did what you thought was right...",
          mood: "final",
          manipulation: null,
        },
      };

      // DOM Elements
      const elements = {
        startScreen: document.getElementById("start-screen"),
        newsScreen: document.getElementById("news-screen"),
        mainGame: document.getElementById("main-game"),
        startButton: document.getElementById("start-button"),
        mainDuck: document.getElementById("main-duck"),
        petButton: document.getElementById("pet-button"),
        punchButton: document.getElementById("punch-button"),
        petProgress: document.getElementById("pet-progress"),
        punchProgress: document.getElementById("punch-progress"),
        petProgressContainer: document.getElementById("pet-progress-container"),
        punchProgressContainer: document.getElementById(
          "punch-progress-container"
        ),
        populationMeter: document.getElementById("population-meter"),
        dyingBar: document.getElementById("dying-bar"),
        curedBar: document.getElementById("cured-bar"),
        populationStats: document.getElementById("population-stats"),
      };

      // Utility Functions
      function updateDuckImage() {
        const duckImage = elements.mainDuck;
        let imagePath = "images/duck.png";

        if (GameState.duckMode === "pet" && GameState.duckStage > 1) {
          imagePath = `images/pet${GameState.duckStage}.png`;
        } else if (GameState.duckMode === "punch" && GameState.duckStage > 1) {
          imagePath = `images/punch${GameState.duckStage}.png`;
        }

        duckImage.src = imagePath;
      }

      function updatePetProgress() {
        const totalPetsNeeded = getCurrentPetRequirement();
        const currentProgress = (GameState.petClicks / totalPetsNeeded) * 100;
        elements.petProgress.style.width = `${Math.min(currentProgress, 100)}%`;
      }

      function updatePunchProgress() {
        const progressPercentage = (GameState.punchProgress / 100) * 100;
        elements.punchProgress.style.width = `${Math.max(
          progressPercentage,
          0
        )}%`;
      }

      function getCurrentPetRequirement() {
        const stageIndex = GameState.duckStage - 1;
        return (
          CONFIG.PET_STAGES[stageIndex] ||
          CONFIG.PET_STAGES[CONFIG.PET_STAGES.length - 1]
        );
      }

      function getCurrentPunchDamage() {
        const stageIndex = GameState.duckStage - 1;
        return (
          CONFIG.PUNCH_STAGES[stageIndex] ||
          CONFIG.PUNCH_STAGES[CONFIG.PUNCH_STAGES.length - 1]
        );
      }

      // Population tracking functions
      function getExponentialValueAtTime(z, N, T) {
        if (T <= 0 || N <= 0) {
          throw new Error(
            "Target number (N) and total time (T) must be positive"
          );
        }
        if (z < 0) {
          throw new Error("Current time (z) must be non-negative");
        }
        return Math.pow(N, z / T);
      }

      function updatePopulationMeter() {
        if (!GameState.gameStartTime) return;

        const currentTime = (Date.now() - GameState.gameStartTime) / 1000 / 60; // minutes

        // Calculate exponential deaths over time (this is the core tragedy)
        GameState.currentDeaths = Math.floor(
          getExponentialValueAtTime(
            currentTime,
            GameState.totalPopulation,
            CONFIG.TOTAL_GAME_TIME
          ) - 1
        );

        // Remaining population calculation
        const savedByPunching = GameState.curedPopulation;
        const actualDeaths = Math.max(
          0,
          GameState.currentDeaths - savedByPunching
        );
        const remainingPopulation = Math.max(
          0,
          GameState.totalPopulation - actualDeaths - savedByPunching
        );

        // Update bars (as percentages of total population)
        const deathPercent = Math.min(
          (actualDeaths / GameState.totalPopulation) * 100,
          100
        );
        const curedPercent = Math.min(
          (savedByPunching / GameState.totalPopulation) * 100,
          100
        );

        elements.dyingBar.style.width = `${deathPercent}%`;
        elements.curedBar.style.width = `${curedPercent}%`;

        // Update stats text
        document.querySelector(".dying-count").textContent =
          formatNumber(actualDeaths);
        document.querySelector(".cured-count").textContent =
          formatNumber(savedByPunching);
        document.querySelector(".remaining-count").textContent =
          formatNumber(remainingPopulation);
      }

      function formatNumber(num) {
        if (num >= 1000000000) return (num / 1000000000).toFixed(1) + "B";
        if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
        if (num >= 1000) return (num / 1000).toFixed(1) + "K";
        return num.toString();
      }

      // Dialogue Management Functions
      function showDialogue(dialogueData, showChoices = false) {
        const overlay = document.getElementById("dialogue-overlay");
        const card = document.getElementById("dialogue-card");
        const text = document.getElementById("dialogue-text");
        const choices = document.getElementById("dialogue-choices");

        // Set dialogue text
        text.textContent = dialogueData.dialogue;

        // Clear existing styling and choices
        card.className = "dialogue-card";
        choices.innerHTML = "";

        // Add mood-based styling
        if (dialogueData.mood) {
          card.classList.add(dialogueData.mood);
        }

        // Show choices if manipulation is present
        if (showChoices && dialogueData.manipulation) {
          const continueBtn = document.createElement("button");
          continueBtn.className = "dialogue-choice-btn continue";
          continueBtn.textContent = "Continue Punching";
          continueBtn.onclick = () => hideDialogue();

          const listenBtn = document.createElement("button");
          listenBtn.className = "dialogue-choice-btn listen";
          listenBtn.textContent = "Listen to Duck";
          listenBtn.onclick = () => showManipulation(dialogueData.manipulation);

          choices.appendChild(continueBtn);
          choices.appendChild(listenBtn);
        }

        // Show overlay
        overlay.classList.add("show");

        // Auto-hide if no choices
        if (!showChoices) {
          setTimeout(() => {
            hideDialogue();
          }, CONFIG.DIALOGUE_DISPLAY_TIME);
        }
      }

      function showManipulation(manipulation) {
        const manipulationDialogue = {
          dialogue: manipulation.text,
          mood: "pleading",
        };
        showDialogue(manipulationDialogue, false);
      }

      function hideDialogue() {
        const overlay = document.getElementById("dialogue-overlay");
        overlay.classList.remove("show");
      }

      function getPetDialogue(stage, petInStage) {
        const stageKey = `stage${stage}`;
        const petKey = `pet${petInStage}`;

        if (PET_DIALOGUE[stageKey] && PET_DIALOGUE[stageKey][petKey]) {
          return PET_DIALOGUE[stageKey][petKey];
        }

        // Fallback dialogue
        return {
          dialogue: "Quack... something is happening to me.",
          mood: "neutral",
        };
      }

      function getPunchDialogue(stage, punchInStage) {
        const stageKey = `stage${stage}`;
        const punchKey = `punch${punchInStage}`;

        if (PUNCH_DIALOGUE[stageKey] && PUNCH_DIALOGUE[stageKey][punchKey]) {
          return PUNCH_DIALOGUE[stageKey][punchKey];
        }

        // Fallback dialogue
        return {
          dialogue: "Ow... why are you doing this?",
          mood: "hurt",
          manipulation: {
            text: "Please stop...",
            type: "simple_plea",
          },
        };
      }

      // Achievement Management System
      const AchievementManager = {
        achievementData: {
          unlockedAchievements: [],
          statistics: {
            gamesStarted: 0,
            totalPets: 0,
            totalPunches: 0,
            totalCured: 0,
            totalKilled: 0,
            fastestActions: 0,
          },
        },

        init: () => {
          AchievementManager.loadFromStorage();
        },

        loadFromStorage: () => {
          try {
            const saved = localStorage.getItem(CONFIG.ACHIEVEMENT_STORAGE_KEY);
            if (saved) {
              const parsed = JSON.parse(saved);
              AchievementManager.achievementData = {
                ...AchievementManager.achievementData,
                ...parsed,
              };
            }
          } catch (error) {
            console.error("Failed to load achievements:", error);
          }
        },

        saveToStorage: () => {
          try {
            localStorage.setItem(
              CONFIG.ACHIEVEMENT_STORAGE_KEY,
              JSON.stringify(AchievementManager.achievementData)
            );
          } catch (error) {
            console.error("Failed to save achievements:", error);
          }
        },

        isUnlocked: (achievementId) => {
          return AchievementManager.achievementData.unlockedAchievements.includes(
            achievementId
          );
        },

        unlockAchievement: (achievementId) => {
          if (!AchievementManager.isUnlocked(achievementId)) {
            AchievementManager.achievementData.unlockedAchievements.push(
              achievementId
            );
            AchievementManager.saveToStorage();
            AchievementManager.showAchievementNotification(achievementId);
            return true;
          }
          return false;
        },

        showAchievementNotification: (achievementId) => {
          const achievement =
            CONFIG.ACHIEVEMENTS[achievementId.toUpperCase().replace(/-/g, "_")];
          if (!achievement) return;

          const notification = document.createElement("div");
          notification.className = "achievement-notification";
          notification.innerHTML = `
                    <div class="achievement-popup">
                        <div class="achievement-icon">${achievement.icon}</div>
                        <div class="achievement-text">
                            <div class="achievement-title">Achievement Unlocked!</div>
                            <div class="achievement-name">${achievement.name}</div>
                            <div class="achievement-desc">${achievement.description}</div>
                        </div>
                    </div>
                `;

          document.body.appendChild(notification);

          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 4000);
        },

        trackGameStarted: () => {
          AchievementManager.achievementData.statistics.gamesStarted++;
          if (
            AchievementManager.achievementData.statistics.gamesStarted === 1
          ) {
            AchievementManager.unlockAchievement("first-game");
          }
          AchievementManager.saveToStorage();
        },

        trackPet: () => {
          AchievementManager.achievementData.statistics.totalPets++;
          if (AchievementManager.achievementData.statistics.totalPets === 1) {
            AchievementManager.unlockAchievement("first-pet");
          }
          AchievementManager.saveToStorage();
        },

        trackPunch: () => {
          AchievementManager.achievementData.statistics.totalPunches++;
          if (
            AchievementManager.achievementData.statistics.totalPunches === 1
          ) {
            AchievementManager.unlockAchievement("first-punch");
          }
          AchievementManager.saveToStorage();
        },

        trackCure: (amount) => {
          AchievementManager.achievementData.statistics.totalCured += amount;
          if (
            AchievementManager.achievementData.statistics.totalCured >=
            1000000000
          ) {
            AchievementManager.unlockAchievement("life-saver");
          }
          AchievementManager.saveToStorage();
        },

        getAllAchievements: () => {
          const achievements = [];
          Object.keys(CONFIG.ACHIEVEMENTS).forEach((key) => {
            const achievement = CONFIG.ACHIEVEMENTS[key];
            achievements.push({
              ...achievement,
              unlocked: AchievementManager.isUnlocked(achievement.id),
            });
          });
          return achievements.sort((a, b) => {
            if (a.unlocked && !b.unlocked) return -1;
            if (!a.unlocked && b.unlocked) return 1;
            return a.name.localeCompare(b.name);
          });
        },

        getStatistics: () => {
          return {
            ...AchievementManager.achievementData.statistics,
            totalUnlocked:
              AchievementManager.achievementData.unlockedAchievements.length,
            totalAchievements: Object.keys(CONFIG.ACHIEVEMENTS).length,
          };
        },
      };

      // Achievement Drawer UI Component
      const AchievementDrawer = {
        isOpen: false,

        init: () => {
          AchievementDrawer.createDrawerHTML();
          AchievementDrawer.attachEventListeners();
        },

        createDrawerHTML: () => {
          const achievementButton = document.createElement("button");
          achievementButton.id = "achievement-button";
          achievementButton.className = "achievement-button";
          achievementButton.innerHTML = "üèÜ";
          achievementButton.title = "View Achievements";

          const drawerOverlay = document.createElement("div");
          drawerOverlay.id = "achievement-drawer-overlay";
          drawerOverlay.className = "achievement-drawer-overlay";

          const drawer = document.createElement("div");
          drawer.id = "achievement-drawer";
          drawer.className = "achievement-drawer";
          drawer.innerHTML = AchievementDrawer.renderDrawerContent();

          drawerOverlay.appendChild(drawer);
          document.body.appendChild(achievementButton);
          document.body.appendChild(drawerOverlay);
        },

        renderDrawerContent: () => {
          const achievements = AchievementManager.getAllAchievements();
          const stats = AchievementManager.getStatistics();
          const unlockedCount = achievements.filter((a) => a.unlocked).length;
          const totalCount = achievements.length;

          return `
                    <div class="achievement-header">
                        <h2>üèÜ Achievements</h2>
                        <div class="achievement-progress">
                            ${unlockedCount}/${totalCount} Unlocked
                        </div>
                        <button id="close-drawer" class="close-drawer-btn">√ó</button>
                    </div>
                    
                    <div class="achievement-content">
                        <div class="achievement-grid">
                            ${achievements
                              .map(
                                (achievement) => `
                                <div class="achievement-item ${
                                  achievement.unlocked ? "unlocked" : "locked"
                                }">
                                    <div class="achievement-icon">${
                                      achievement.unlocked
                                        ? achievement.icon
                                        : "üîí"
                                    }</div>
                                    <div class="achievement-info">
                                        <div class="achievement-name">${
                                          achievement.unlocked
                                            ? achievement.name
                                            : "???"
                                        }</div>
                                        <div class="achievement-description">${
                                          achievement.unlocked
                                            ? achievement.description
                                            : "Hidden achievement"
                                        }</div>
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                        
                        <div class="achievement-stats">
                            <h3>üìä Statistics</h3>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Games Started:</span>
                                    <span class="stat-value">${
                                      stats.gamesStarted
                                    }</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Total Pets:</span>
                                    <span class="stat-value">${
                                      stats.totalPets
                                    }</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Total Punches:</span>
                                    <span class="stat-value">${
                                      stats.totalPunches
                                    }</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">People Cured:</span>
                                    <span class="stat-value">${formatNumber(
                                      stats.totalCured
                                    )}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">People Killed:</span>
                                    <span class="stat-value">${formatNumber(
                                      stats.totalKilled
                                    )}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Unlocked:</span>
                                    <span class="stat-value">${
                                      stats.totalUnlocked
                                    }/${stats.totalAchievements}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
        },

        attachEventListeners: () => {
          const achievementButton =
            document.getElementById("achievement-button");
          const drawerOverlay = document.getElementById(
            "achievement-drawer-overlay"
          );

          if (achievementButton) {
            achievementButton.addEventListener("click", () => {
              AchievementDrawer.toggleDrawer();
            });
          }

          if (drawerOverlay) {
            drawerOverlay.addEventListener("click", (e) => {
              if (e.target === drawerOverlay) {
                AchievementDrawer.closeDrawer();
              }
            });
          }
        },

        toggleDrawer: () => {
          if (AchievementDrawer.isOpen) {
            AchievementDrawer.closeDrawer();
          } else {
            AchievementDrawer.openDrawer();
          }
        },

        openDrawer: () => {
          const drawerOverlay = document.getElementById(
            "achievement-drawer-overlay"
          );
          const drawer = document.getElementById("achievement-drawer");

          if (drawerOverlay && drawer) {
            drawer.innerHTML = AchievementDrawer.renderDrawerContent();

            const closeButton = document.getElementById("close-drawer");
            if (closeButton) {
              closeButton.addEventListener("click", () => {
                AchievementDrawer.closeDrawer();
              });
            }

            drawerOverlay.style.display = "flex";
            setTimeout(() => {
              drawerOverlay.classList.add("open");
              drawer.classList.add("open");
            }, 10);

            AchievementDrawer.isOpen = true;
          }
        },

        closeDrawer: () => {
          const drawerOverlay = document.getElementById(
            "achievement-drawer-overlay"
          );
          const drawer = document.getElementById("achievement-drawer");

          if (drawerOverlay && drawer) {
            drawerOverlay.classList.remove("open");
            drawer.classList.remove("open");

            setTimeout(() => {
              drawerOverlay.style.display = "none";
            }, 300);

            AchievementDrawer.isOpen = false;
          }
        },

        updateIfOpen: () => {
          if (AchievementDrawer.isOpen) {
            const drawer = document.getElementById("achievement-drawer");
            if (drawer) {
              drawer.innerHTML = AchievementDrawer.renderDrawerContent();
              const closeButton = document.getElementById("close-drawer");
              if (closeButton) {
                closeButton.addEventListener("click", () => {
                  AchievementDrawer.closeDrawer();
                });
              }
            }
          }
        },
      };

      // Game Logic Functions
      function handlePetClick() {
        if (GameState.punchingStarted) return;

        GameState.duckMode = "pet";
        GameState.petClicks++;

        // PETTING DOES NOT CURE ANYONE - only transforms the duck
        AchievementManager.trackPet();

        // Show pet dialogue
        const petInStage =
          ((GameState.petClicks - 1) % getCurrentPetRequirement()) + 1;
        const dialogueData = getPetDialogue(GameState.duckStage, petInStage);
        showDialogue(dialogueData);

        // Track moral dilemma achievement (petting while people die)
        if (GameState.currentDeaths > 1000000) {
          // 1 million+ dead
          AchievementManager.unlockAchievement("moral-dilemma");
        }

        const petsNeeded = getCurrentPetRequirement();

        if (GameState.petClicks >= petsNeeded) {
          // Advance to next pet stage
          if (GameState.duckStage < CONFIG.TOTAL_PET_STAGES) {
            GameState.duckStage++;
            GameState.petClicks = 0;
            updateDuckImage();

            // Track mutation witness achievement
            if (GameState.duckStage >= 6) {
              AchievementManager.unlockAchievement("mutation-witness");
            }

            // Check for perfect ending
            if (GameState.duckStage === CONFIG.TOTAL_PET_STAGES) {
              AchievementManager.unlockAchievement("pet-master");
              setTimeout(() => {
                showPerfectEnding();
              }, CONFIG.DIALOGUE_DISPLAY_TIME + 500);
              return;
            }
          }
        }

        updatePetProgress();
        updatePopulationMeter();
        AchievementDrawer.updateIfOpen();

        // Add click animation
        elements.petButton.style.transform = "scale(0.9)";
        setTimeout(() => {
          elements.petButton.style.transform = "scale(1)";
        }, 100);
      }

      function handlePunchClick() {
        if (!GameState.punchingStarted) {
          // First punch - disable petting and switch to punch mode
          GameState.punchingStarted = true;
          GameState.duckMode = "punch";
          GameState.duckStage = 1;

          // Hide pet progress, show punch progress
          elements.petProgressContainer.classList.add("hidden");
          elements.punchProgressContainer.classList.remove("hidden");

          // Disable pet button
          elements.petButton.disabled = true;
        }

        const damage = getCurrentPunchDamage();
        GameState.punchProgress = Math.max(0, GameState.punchProgress - damage);
        GameState.punchClicks++;

        // PUNCHING CURES PEOPLE - this is the moral dilemma!
        GameState.curedPopulation += CONFIG.CURE_PER_PUNCH;
        AchievementManager.trackPunch();
        AchievementManager.trackCure(CONFIG.CURE_PER_PUNCH);

        // Show punch dialogue with potential manipulation choices
        const punchStage = getPunchStage();
        const punchInStage = GameState.punchClicks;
        const dialogueData = getPunchDialogue(punchStage, punchInStage);
        const showChoices = punchStage >= 4 && dialogueData.manipulation; // Start manipulation at stage 4
        showDialogue(dialogueData, showChoices);

        // Check achievements
        if (GameState.curedPopulation >= 1000000000) {
          AchievementManager.unlockAchievement("life-saver");
        }

        // Check if we should advance to next punch stage
        const stageThresholds = [
          90, 80, 70, 60, 50, 40, 30, 20, 10, 5, 2, 1, 0,
        ];
        const currentThreshold = stageThresholds[GameState.duckStage - 1];

        if (
          GameState.punchProgress <= currentThreshold &&
          GameState.duckStage < CONFIG.TOTAL_PUNCH_STAGES
        ) {
          GameState.duckStage++;
          updateDuckImage();
        }

        updatePunchProgress();
        updatePopulationMeter();
        AchievementDrawer.updateIfOpen();

        // Add click animation
        elements.punchButton.style.transform = "scale(0.9)";
        setTimeout(() => {
          elements.punchButton.style.transform = "scale(1)";
        }, 100);

        // Check if duck is defeated
        if (GameState.punchProgress <= 0) {
          AchievementManager.unlockAchievement("punch-master");
          // Show death dialogue
          setTimeout(() => {
            showDialogue(PUNCH_DIALOGUE.death);
            setTimeout(() => {
              showPunchEnding();
            }, CONFIG.DIALOGUE_DISPLAY_TIME);
          }, 500);
        }
      }

      function getPunchStage() {
        // Calculate punch stage based on current HP
        if (GameState.punchProgress > 90) return 1;
        if (GameState.punchProgress > 80) return 2;
        if (GameState.punchProgress > 70) return 3;
        if (GameState.punchProgress > 60) return 4;
        if (GameState.punchProgress > 50) return 5;
        return 5; // Keep at stage 5 for remaining punches
      }

      function showPerfectEnding() {
        // Clear death timer
        if (GameState.deathTimer) {
          clearInterval(GameState.deathTimer);
          GameState.deathTimer = null;
        }

        // Show final transformation dialogue
        const finalDialogue = {
          dialogue:
            "You have passed the test. Few beings show such compassion when faced with impossible choices. I will now cure everyone... and bring back those who have fallen.",
          mood: "innocent",
        };

        showDialogue(finalDialogue);

        setTimeout(() => {
          // Perfect ending: Duck reveals it was a test and cures EVERYONE + brings back the dead
          GameState.curedPopulation = GameState.totalPopulation; // Cure everyone
          GameState.currentDeaths = 0; // Bring back the dead
          updatePopulationMeter();

          alert(
            `üïäÔ∏è PERFECT ENDING üïäÔ∏è\n\nThe duck transforms back into its innocent form.\n\nAll 8 billion humans are saved and the dead are revived!\n\nCompassion triumphed over fear.`
          );
          resetGame();
        }, CONFIG.DIALOGUE_DISPLAY_TIME);
      }

      function showPunchEnding() {
        // Clear death timer
        if (GameState.deathTimer) {
          clearInterval(GameState.deathTimer);
          GameState.deathTimer = null;
        }

        const totalSaved = GameState.curedPopulation;
        const totalDead = GameState.currentDeaths;

        if (totalSaved > totalDead) {
          alert(
            `‚öîÔ∏è VIOLENT HERO ‚öîÔ∏è\n\nYou defeated the duck through violence.\n\nHumanity is saved, but at what cost?\n\nSaved: ${formatNumber(
              totalSaved
            )}\nLost: ${formatNumber(totalDead)}`
          );
        } else {
          alert(
            `üíÄ NECESSARY SACRIFICE üíÄ\n\nThe duck is defeated, but so many have perished...\n\nSaved: ${formatNumber(
              totalSaved
            )}\nLost: ${formatNumber(totalDead)}\n\nWas the violence worth it?`
          );
        }
        resetGame();
      }

      function resetGame() {
        // Clear death timer if running
        if (GameState.deathTimer) {
          clearInterval(GameState.deathTimer);
          GameState.deathTimer = null;
        }

        GameState.currentScreen = "start";
        GameState.duckStage = 1;
        GameState.duckMode = "neutral";
        GameState.petProgress = 0;
        GameState.punchProgress = 100;
        GameState.petClicks = 0;
        GameState.punchClicks = 0;
        GameState.punchingStarted = false;
        GameState.totalPopulation = 8000000000;
        GameState.currentDeaths = 0;
        GameState.curedPopulation = 0;
        GameState.gameStartTime = null;

        // Reset UI
        elements.startScreen.classList.remove("fade-out");
        elements.newsScreen.classList.remove("slide-up");
        elements.mainGame.classList.remove("active");
        elements.petButton.disabled = false;
        elements.petProgressContainer.classList.remove("hidden");
        elements.punchProgressContainer.classList.add("hidden");

        updateDuckImage();
        updatePetProgress();
        updatePunchProgress();
        updatePopulationMeter();
      }

      // Screen Transition Functions
      function showNewsScreen() {
        elements.startScreen.classList.add("fade-out");
        setTimeout(() => {
          elements.newsScreen.classList.add("slide-up");
          GameState.currentScreen = "news";
        }, 500);
      }

      function showMainGame() {
        elements.newsScreen.classList.remove("slide-up");
        setTimeout(() => {
          elements.mainGame.classList.add("active");
          GameState.currentScreen = "main";

          // Start the game timer and population tracking
          GameState.gameStartTime = Date.now();
          AchievementManager.trackGameStarted();

          // Start death timer
          GameState.deathTimer = setInterval(updatePopulationMeter, 1000);
        }, 300);
      }

      // Event Listeners
      elements.startButton.addEventListener("click", showNewsScreen);
      elements.newsScreen.addEventListener("click", showMainGame);
      elements.petButton.addEventListener("click", handlePetClick);
      elements.punchButton.addEventListener("click", handlePunchClick);

      // Initialize game systems
      AchievementManager.init();
      AchievementDrawer.init();

      // Initialize game
      updateDuckImage();
      updatePetProgress();
      updatePunchProgress();
      updatePopulationMeter();
    </script>
  </body>
</html>
